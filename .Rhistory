df_Cost = data.frame(aggregate(total_cost ~
business_model + fulfilment_strategy,
data=TableBind, sum))
# Beide DataFrames mergen
df_Compare = cbind(df_Revenue, df_Cost$total_cost)
df_Compare
#TODO: Grafik hierzu waere gut
# Umsatz aggrerieren
df_Revenue = data.frame(aggregate(total_revenue ~
business_model + fulfilment_strategy,
data=TableBind, sum))
# Kosten aggrerieren
df_Cost = data.frame(aggregate(total_cost ~
business_model + fulfilment_strategy,
data=TableBind, sum))
# Beide DataFrames mergen
df_Compare = cbind(df_Revenue, total_cost)
# Umsatz aggrerieren
df_Revenue = data.frame(aggregate(total_revenue ~
business_model + fulfilment_strategy,
data=TableBind, sum))
# Kosten aggrerieren
df_Cost = data.frame(aggregate(total_cost ~
business_model + fulfilment_strategy,
data=TableBind, sum))
# Beide DataFrames mergen
df_Compare = cbind(df_Revenue, df_Cost$total_cost)
df_Compare
#TODO: Grafik hierzu waere gut
# Umsatz aggrerieren
df_Revenue = data.frame(aggregate(total_revenue ~
business_model + fulfilment_strategy,
data=TableBind, sum))
# Kosten aggrerieren
df_Cost = data.frame(aggregate(total_cost ~
business_model + fulfilment_strategy,
data=TableBind, sum))
# Beide DataFrames mergen
df_Compare = cbind(df_Revenue, df_Cost$total_cost)
df_Compare[4] = "total_cost"
#TODO: Grafik hierzu waere gut
df_Compare
# Umsatz aggrerieren
df_Revenue = data.frame(aggregate(total_revenue ~
business_model + fulfilment_strategy,
data=TableBind, sum))
# Kosten aggrerieren
df_Cost = data.frame(aggregate(total_cost ~
business_model + fulfilment_strategy,
data=TableBind, sum))
# Beide DataFrames mergen
df_Compare = cbind(df_Revenue, df_Cost$total_cost)
df_Compare[4] = "total_cost"
df_Compare
#TODO: Grafik hierzu waere gut
# Umsatz aggrerieren
df_Revenue = data.frame(aggregate(total_revenue ~
business_model + fulfilment_strategy,
data=TableBind, sum))
# Kosten aggrerieren
df_Cost = data.frame(aggregate(total_cost ~
business_model + fulfilment_strategy,
data=TableBind, sum))
# Beide DataFrames mergen
df_Compare = cbind(df_Revenue, df_Cost$total_cost)
colnames(df_Compare)[4] = "total_cost"
df_Compare
#TODO: Grafik hierzu waere gut
# Umsatz aggrerieren
df_Revenue = data.frame(aggregate(total_revenue ~
business_model + fulfilment_strategy,
data=TableBind, sum))
# Kosten aggrerieren
df_Cost = data.frame(aggregate(total_cost ~
business_model + fulfilment_strategy,
data=TableBind, sum))
# Beide DataFrames mergen
df_Compare = cbind(df_Revenue, df_Cost$total_cost)
#umbenennen
colnames(df_Compare)[4] = "total_cost"
df_Compare
#TODO: Grafik hierzu waere gut
group1 = aggregate(transport_price_booked ~
fulfilment_strategy + business_model, data=shipments, sum)
group2 = aggregate(transport_cost_assigned  ~
fulfilment_strategy + business_model, data=shipments, sum)
differenz = group1[3] - group2[3]
colnames(differenz) = "differenz"
groupbind = cbind(group1, group2[3], differenz)
groupbind
#TODO: Grafik von entstandene Kosten bei Lieferung waere gut
library(readr)
library(dplyr)
library("zoo")
library("forecast")
library("ggplot2")
library("mosaic")
library("Metrics")
library("dummies")
shipments <- read.csv("data/shipment_FINAL_20210115.csv")
margin <- read.csv("data/margin_by_week_FINAL_20210115.csv")
head(shipments)
head(margin)
str(shipments)
str(margin)
# Datum von Shipment Spalte "last_stop_requested_arrival_to_date" umformatieren,
# sodass Kalenderwoche angezeigt wird
CalendarWeekFormat = as.Date(shipments$last_stop_requested_arrival_to_date)
shipments$CalendarWeek = strftime(CalendarWeekFormat, format = "%Y-%V") #Year-CalendarWeek
# Unbenennen der ersten Spalte der Tabelle margin
colnames(margin)[1] = c("CalendarWeek")
# Beide Tabellen "shipments" und "margin" nach "CalendarWeek" mergen
TableBind = merge(shipments, margin, by = "CalendarWeek")
head(TableBind)
#TODO: Zeitliche Grafik mit Umsaetzen + Kosten hierzu waere gut
# Umsatz aggrerieren
df_Revenue = data.frame(aggregate(total_revenue ~
business_model + fulfilment_strategy,
data=TableBind, sum))
# Kosten aggrerieren
df_Cost = data.frame(aggregate(total_cost ~
business_model + fulfilment_strategy,
data=TableBind, sum))
# Beide DataFrames mergen
df_Compare = cbind(df_Revenue, df_Cost$total_cost)
#umbenennen
colnames(df_Compare)[4] = "total_cost"
df_Compare
#TODO: Grafik von Kosten und Einnahmen hierzu waere gut
group1 = aggregate(transport_price_booked ~
fulfilment_strategy + business_model, data=shipments, sum)
group2 = aggregate(transport_cost_assigned  ~
fulfilment_strategy + business_model, data=shipments, sum)
differenz = group1[3] - group2[3]
colnames(differenz) = "differenz"
groupbind = cbind(group1, group2[3], differenz)
groupbind
#TODO: Grafik von entstandene Kosten bei Lieferung waere gut
shipments %>%
group_by(business_model) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
#rm(list = ls())
library("readr")
library("dplyr")
library("zoo")
library("forecast")
library("ggplot2")
library("mosaic")
library("Metrics")
library("dummies")
library("janitor")
install.packages("plotly")
library("plotly")
shipments %>%
group_by(business_model) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
shipments %>%
group_by(business_model) %>%
summarize(mean_margin = mean(margin))
shipments_without_cancellation = subset(shipments, shipment_state != "cancelled")
shipments_without_cancellation$margin = shipments_without_cancellation$total_revenue - shipments_without_cancellation$total_cost
inspect(shipments_without_cancellation)
shipments_without_cancellation = subset(shipments, shipment_state != "cancelled")
shipments_without_cancellation$margin = shipments_without_cancellation$total_revenue - shipments_without_cancellation$total_cost
inspect(shipments_without_cancellation)
shipments %>%
group_by(business_model) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
shipments_without_cancellation %>%
group_by(business_model) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
shipments_without_cancellation %>%
group_by(business_model) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
ggplot(shipments_without_cancellation,
aes(factor(business_model),
fill = factor(business_model))) +
geom_bar()
# durchschnittliche Marge, aggregiert nach custom rate shipment (falsch, wahr)
shipments_without_cancellation %>%
group_by(custom_rate_shipment) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
# Visualisierung
tapply(shipments_without_cancellation$margin ,shipments_without_cancellation$custom_rate_shipment ,sum)
# Visualisierung
tapply(shipments_without_cancellation$margin ,shipments_without_cancellation$custom_rate_shipment ,sum)
# durchschnittliche Marge, aggregiert nach custom rate shipment (falsch, wahr)
shipments_without_cancellation %>%
group_by(custom_rate_shipment) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
# Visualisierung
tapply(shipments_without_cancellation$margin ,shipments_without_cancellation$custom_rate_shipment ,sum)
tapply(shipments_without_cancellation$margin ,shipments_without_cancellation$custom_rate_shipment ,sum)
tapply(shipments_without_cancellation$margin ,shipments_without_cancellation$custom_rate_shipment ,sum)
# durchschnittliche Marge, aggregiert nach custom rate shipment (falsch, wahr)
shipments_without_cancellation %>%
group_by(custom_rate_shipment) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
#rm(list = ls())
library("readr")
library("dplyr")
library("zoo")
library("forecast")
library("ggplot2")
library("mosaic")
library("Metrics")
library("dummies")
library("janitor")
install.packages("plotly")
library("plotly")
shipments_without_cancellation = subset(shipments, shipment_state != "cancelled")
shipments_without_cancellation$margin = shipments_without_cancellation$total_revenue - shipments_without_cancellation$total_cost
inspect(shipments_without_cancellation)
# durchschnittliche Marge, aggregiert nach buusiness model (3PL, 4PL)
shipments_without_cancellation %>%
group_by(business_model) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
# VIsualisierung
ggplot(shipments_without_cancellation,
aes(factor(business_model),
fill = factor(business_model))) +
geom_bar()
# durchschnittliche Marge, aggregiert nach custom rate shipment (falsch, wahr)
shipments_without_cancellation %>%
group_by(custom_rate_shipment) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
# Visualisierung
tapply(shipments_without_cancellation$margin ,shipments_without_cancellation$custom_rate_shipment ,sum)
# Visualisierung
tapply(shipments_without_cancellation$margin ,shipments_without_cancellation$custom_rate_shipment ,sum)
# Visualisierung
tapply(shipments_without_cancellation$margin ,shipments_without_cancellation$custom_rate_shipment ,sum)
View(shipments_without_cancellation)
# Visualisierung
tapply(shipments_without_cancellation$margin ,shipments_without_cancellation$custom_rate_shipment ,sum)
shipments_without_cancellation %>%
group_by(custom_rate_shipment) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
tapply(shipments_without_cancellation$margin ,shipments_without_cancellation$custom_rate_shipment ,sum)
ggplot(shipments_without_cancellation,
aes(factor(custom_rate_shipment),
fill = factor(custom_rate_shipment))) +
geom_bar()
shipments_without_cancellation %>%
group_by(fulfilment_strategy) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
tapply(shipments_without_cancellation$margin ,shipments_without_cancellation$fulfilment_strategy ,sum)
# Visualisierung
ggplot(shipments_without_cancellation,
aes(factor(fulfilment_strategy),
fill = factor(fulfilment_strategy))) +
geom_bar()
xtabs(~ custom_rate_shipment + fulfilment_strategy, data = shipments_without_cancellation)
shipments_without_cancellation %>%
group_by(lane_domain) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
shipments_without_cancellation %>%
group_by(lane_domain) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
tapply(shipments_without_cancellation$margin ,shipments_without_cancellation$lane_domain ,sum)
ggplot(shipments_without_cancellation,
aes(factor(lane_domain),
fill = factor(lane_domain))) +
geom_bar()
cor(shipments_without_cancellation$stops_count, shipments_without_cancellation$margin)
cor(shipments_without_cancellation$stops_count, shipments_without_cancellation$margin, method = "kendall")
cor(shipments_without_cancellation$stops_count, shipments_without_cancellation$margin, method = "spearman")
#rm(list = ls())
library("readr")
library("dplyr")
library("zoo")
library("forecast")
library("ggplot2")
library("mosaic")
library("Metrics")
library("dummies")
library("janitor")
#install.packages("plotly")
library("plotly")
# Shipments Daten einlesen und ins richtige Format bringen.
shipments <- read.csv("data/shipment_FINAL_20210115.csv")
# Timestamps
shipments$shipment_created_at = as.POSIXct(shipments$shipment_created_at,tz=Sys.timezone())
shipments[shipments$smh_accepted_first_state_change == "",]$smh_accepted_first_state_change = NA
shipments$smh_accepted_first_state_change = as.POSIXct(shipments$smh_accepted_first_state_change,tz=Sys.timezone())
shipments[shipments$smh_accepted_last_state_change == "",]$smh_accepted_last_state_change = NA
shipments$smh_accepted_last_state_change = as.POSIXct(shipments$smh_accepted_last_state_change,tz=Sys.timezone())
shipments$first_stop_requested_arrival_to = as.POSIXct(shipments$first_stop_requested_arrival_to,tz=Sys.timezone())
shipments$first_stop_agreed_arrival_to = as.POSIXct(shipments$first_stop_agreed_arrival_to,tz=Sys.timezone())
shipments[shipments$last_stop_agreed_arrival_to == "",]$last_stop_agreed_arrival_to = NA
shipments$last_stop_agreed_arrival_to = as.POSIXct(shipments$last_stop_agreed_arrival_to,tz=Sys.timezone())
shipments[shipments$first_stop_actual_arrival == "",]$first_stop_actual_arrival = NA
shipments$first_stop_actual_arrival = as.POSIXct(shipments[shipments$first_stop_actual_arrival != "",]$first_stop_actual_arrival,tz=Sys.timezone())
shipments[shipments$last_stop_requested_arrival_to == "",]$last_stop_requested_arrival_to = NA
shipments$last_stop_requested_arrival_to = as.POSIXct(shipments$last_stop_requested_arrival_to,tz=Sys.timezone())
shipments[shipments$last_stop_actual_arrival == "",]$last_stop_actual_arrival = NA
shipments$last_stop_actual_arrival = as.POSIXct(shipments[shipments$last_stop_actual_arrival != "",]$last_stop_actual_arrival,tz=Sys.timezone())
shipments[shipments$sh_cancelled == "",]$sh_cancelled = NA
shipments$sh_cancelled = as.POSIXct(shipments[shipments$sh_cancelled != "",]$sh_cancelled,tz=Sys.timezone())
# Dates
shipments$first_stop_requested_arrival_to_date = shipments$first_stop_requested_arrival_to_date %>% as.Date()
shipments$last_stop_requested_arrival_to_date = shipments$last_stop_requested_arrival_to_date %>% as.Date()
# Margin Daten einlesen
margin <- read.csv2("data/margin_by_week_FINAL_20210115.csv")
head(shipments)
head(margin)
str(shipments)
str(margin)
# Shipments Datenbereinigung
#1. Entferne Zeilen mit leerer lane_domain. Betrifft 2 Zeilen.
shipments = shipments[shipments$lane_domain != "",]
#2. Entferne Zeilen mit cancellation_reason = fake_order. Betrifft 1622 Zeilen.
shipments = shipments[shipments$cancellation_reason != "fake_order",]
#3. Ändere 2024 zu 2020 in last_stop_requested_arrival_to und last_stop_requested_arrival_to_date Spalte. Betrifft 1 Zeile.
shipments[shipments$last_stop_requested_arrival_to == "2024-11-20 07:00:00",]$last_stop_requested_arrival_to = "2020-11-20 07:00:00"
shipments[shipments$last_stop_requested_arrival_to_date == "2024-11-20",]$last_stop_requested_arrival_to_date = "2020-11-20"
#4. Ändere 0019 zu 2019. Betrifft 1 Zeile.
shipments$first_stop_actual_arrival = ifelse(!is.na(shipments$first_stop_actual_arrival) & shipments$first_stop_actual_arrival == "0019-08-20 01:53:28", "2019-08-20 01:53:28", NA)
#5. Prüfen auf Duplikate insgesamt und für shipment_reference speziell. Betrifft 0 Zeilen.
#shipments = shipments %>%  distinct(.)
#shipments <- shipments[!duplicated(shipments$shipment_reference),]
#6. Entferne ersten 4 Zeilen, siehe Forum. Betrifft 4 Zeilen.
shipments = shipments[-1:-4,]
#7. Entferne weitere Zeile, da es nur 1 Tag vom ganzen Monat ist. Betrifft 1 Zeile.
shipments = shipments[-1,]
#8. Entferne Zeile mit -1 in transport_cost_assigned, da dies laut Dokumentation nicht sein kann. Selbes für transport_price_booked. Betrifft 1 Zeile.
shipments = shipments[shipments$transport_price_booked >= 0 & shipments$transport_cost_assigned >= 0,]
#9. Ausreißer bei total_revenue und total_cost entfernen.
plot(x=shipments$total_revenue, y=shipments$total_cost)# Vorher
shipments = shipments[shipments$total_revenue < 5000 & shipments$total_revenue > -1000 & shipments$total_cost > -1000,]
plot(x=shipments$total_revenue, y=shipments$total_cost)# Nachher
#10. transport_cost_assigned und transport_price_booked dürfen nur größer/gleich 0 sein.
shipments = shipments[shipments$transport_cost_assigned >= 0 & shipments$transport_price_booked >= 0,]
#11. Entferne Zeilen die nur NA haben.
shipments = shipments[!is.na(shipments$shipment_reference), ]
#TODO OTD noch berechnen
# Extrahieren von Jahr-Monat aus Shipment-Spalte "last_stop_requested_arrival_to_date",
# da diese Spalte auch in Margin-Spalte vorhanden ist
x <- as.Date(TableBind$last_stop_requested_arrival_to_date, format="%Y-%m-%d")
# Jahr-Monat an die Shipment Spalte hinten anhaengen
TableBind$YearMonth = format(x,"%Y-%m")
#Info: Benoetigen wir spaeter fuer die Zeitreihenanalyse und Vorhersage
# Umsatz aggrerieren
df_Revenue = data.frame(aggregate(
total_revenue ~ business_model + fulfilment_strategy, data=TableBind, sum))
# Kosten aggrerieren
df_Cost = data.frame(aggregate(
total_cost ~ business_model + fulfilment_strategy, data=TableBind, sum))
# Beide DataFrames mergen
df_Compare = cbind(df_Revenue, df_Cost$total_cost)
# Umbenennen
colnames(df_Compare)[4] = "total_cost"
df_Compare
# Verkettung der zwei Tabellen: Shipments + Mergin
# Datum von Shipment Spalte "last_stop_requested_arrival_to_date" so umformatieren, dass Kalenderwoche angezeigt wird
YearMonthFormat = as.Date(shipments$shipment_created_at)
shipments$YearMonth = strftime(YearMonthFormat, format = "%Y-%m") #Jahr-Monat
# Revenue und Costdarstellen
shipments_week_aggregated = shipments[c("YearMonth", "total_revenue", "total_cost")] %>%
aggregate(. ~ YearMonth, data = ., sum)
shipments_week_aggregated$margin =
shipments_week_aggregated$total_revenue - shipments_week_aggregated$total_cost
shipments_week_aggregated
# Liniendiagram von Kosten, Umsatz und Marge
ggplot(data = shipments_week_aggregated, aes(x = YearMonth, group=1)) +
geom_line(aes(y = total_cost), colour="red") +
geom_line(aes(y = total_revenue), colour="darkgreen") +
geom_line(aes(y = margin), colour="black") +
xlab("Date") +
ylab("Euro") +
ggtitle(label = "Instafreight: Umsatz, Kosten und Marge (2017-2021)") +
theme(axis.text.x = element_text(angle=45, vjust = 1.1, hjust=1.2, size=8)) +
#y-Achse Zahlen als Integer-Wert deklarieren
scale_y_continuous(labels = scales::number_format(accuracy = 100)) +
scale_x_discrete(breaks = shipments_week_aggregated$YearMonth[seq(1, length(shipments_week_aggregated$YearMonth), by = 2)])
# Zweites Liniendiagram nur mit Marge
ggplot(data = shipments_week_aggregated, aes(x = YearMonth, group=1)) +
geom_line(aes(y = margin), colour="black") +
xlab("Date") +
ylab("Euro") +
ggtitle(label = "Instafreight: Marge (2017-2021)") +
theme(axis.text.x = element_text(angle=45, vjust = 1.1, hjust=1.2, size=8)) +
#y-Achse Zahlen als Integer-Wert deklarieren
scale_y_continuous(breaks = function(x) unique(floor(pretty(seq(0, (max(x) + 1) * 1.1))))) +
# Periode in 6 Jahrsabstaenden wiedergeben
scale_x_discrete(breaks = shipments_week_aggregated$YearMonth[seq(1, length(shipments_week_aggregated$YearMonth), by = 2)])
#TODO Y besser darstellen
#TODO Legende fehlt
# Aggregieren
shipments_week_aggregated = shipments[c("YearMonth", "transport_price_booked", "transport_cost_assigned")] %>%
aggregate(. ~ YearMonth, data = ., sum)
shipments_week_aggregated$difference =
shipments_week_aggregated$transport_price_booked - shipments_week_aggregated$transport_cost_assigned
shipments_week_aggregated
# Liniendiagramm Uebersicht
ggplot(data = shipments_week_aggregated, aes(x = YearMonth, group=1)) +
geom_line(aes(y = transport_price_booked), colour="red") +
geom_line(aes(y = transport_cost_assigned), colour="blue") +
geom_line(aes(y = difference), colour="black") +
xlab("Date") +
ylab("Euro") +
ggtitle(label = "Instafreight: Buchungspreis, Transportkosten und Differenz (2017-2021)") +
theme(axis.text.x = element_text(angle=45, vjust = 1.1, hjust=1.2, size=8)) +
#y-Achse Zahlen als Integer-Wert deklarieren
scale_y_continuous(labels = scales::number_format(accuracy = 100)) +
scale_x_discrete(breaks = shipments_week_aggregated$YearMonth[seq(1, length(shipments_week_aggregated$YearMonth), by = 2)])
# Liniendiagramm Differenz
ggplot(data = shipments_week_aggregated, aes(x = YearMonth, group=1)) +
geom_line(aes(y = difference), colour="black") +
xlab("Date") +
ylab("Euro") +
ggtitle(label = "Instafreight: Differenz zu Buchungs- und Transportkoste (2017-2021)") +
theme(axis.text.x = element_text(angle=45, vjust = 1.1, hjust=1.2, size=8)) +
#y-Achse Zahlen als Integer-Wert deklarieren
scale_y_continuous(labels = scales::number_format(accuracy = 100)) +
scale_x_discrete(breaks = shipments_week_aggregated$YearMonth[seq(1, length(shipments_week_aggregated$YearMonth), by = 2)])
#TODO Y besser darstellen
#TODO Legende fehlt
# Revenue und Costdarstellen
shipments_week_aggregated = shipments[c("shipment_created_at", "total_revenue", "total_cost")] %>% aggregate(. ~ shipment_created_at, data = ., sum)
shipments_week_aggregated$profit = shipments_week_aggregated$total_revenue - shipments_week_aggregated$total_cost
ggplot(data = shipments_week_aggregated, aes(x = shipment_created_at, group=1)) +
geom_line(aes(y = total_cost), colour="red") +
geom_line(aes(y = total_revenue), colour="blue") +
geom_line(aes(y = profit), colour="black") +
xlab("Date") +
ylab("Euro") +
ggtitle(label = "Instafreight: Revenue, Cost, and Profit group by shipment_created_at") +
theme(axis.text.x = element_text(angle=45, vjust = 1.1, hjust=1.2, size=8)) +
scale_y_continuous(breaks=NULL)
#TODO X Achse zu Monaten umwandeln
#TODO Ausreisser bereinigen.
group1 = aggregate(transport_price_booked ~
fulfilment_strategy + business_model, data=shipments, sum)
group2 = aggregate(transport_cost_assigned  ~
fulfilment_strategy + business_model, data=shipments, sum)
differenz = group1[3] - group2[3]
colnames(differenz) = "differenz"
# Spalten von Dataframes werden verbunden
groupbind = cbind(group1, group2[3], differenz)
groupbind
#TODO: Datenbereinigen mit unique() und ungleich null
#TODO: Grafik von entstandene Kosten bei Lieferung waere gut
ggplot(data = margin, aes(x = first_stop_requested_arrival_to_week, y = forecasted_margin_3pl, group=1)) +
geom_line()+
geom_point()+
xlab("Week") +
ylab("Prozent (%)") +
ggtitle(label = "Instafreight: Weekly Margin (2018-2021)") +
theme(axis.text.x = element_text(angle=45, vjust = 1.1, hjust=1.2, size=8)) +
scale_x_discrete(breaks = margin$first_stop_requested_arrival_to_week[seq(1, length(margin$first_stop_requested_arrival_to_week), by = 10)])
#Anteil von cancelled_shipment_count_3pl berechnen
margin$cancel_rate_3pl = round( ((margin$shipment_count_3pl-margin$non_cancelled_shipment_count_3pl)/margin$shipment_count_3pl)*100,2)
#Visualisierung
plot_ly(data = margin,x= ~first_stop_requested_arrival_to_week,
y= ~cancel_rate_3pl ,type = "bar")
#margin in Euro fuer alle 3PL-Shipments
margin$forecasted_margin_3pl_Euro = round( (margin$forecasted_revenue_3pl*(margin$forecasted_margin_3pl/100)),2)
#margin in Euro fuer 3PL custom_rate shipments
margin$forecasted_margin_3pl_custom_rate_Euro = round( (margin$forecasted_revenue_3pl_custom_rate*(margin$forecasted_margin_3pl_custom_rate/100)),2)
#margin in Euro fuer 3PL spot shipments
margin$forecasted_margin_3pl_spot_Euro = round( (margin$forecasted_revenue_3pl_spot*(margin$forecasted_margin_3pl_spot/100)),2)
# Visualisierung
plot_ly(data = margin,x= ~first_stop_requested_arrival_to_week,
y= ~forecasted_margin_3pl_custom_rate_Euro,type = "bar", name = "custom_rate") %>%
add_trace(y= ~forecasted_margin_3pl_spot_Euro, name ="spot")%>%
layout(yaxis = list(title = 'margin in Euro'), barmode = 'stack')
shipments_without_cancellation = subset(shipments, shipment_state != "cancelled")
shipments_without_cancellation$margin = shipments_without_cancellation$total_revenue - shipments_without_cancellation$total_cost
inspect(shipments_without_cancellation)
# durchschnittliche Marge, aggregiert nach buusiness model (3PL, 4PL)
shipments_without_cancellation %>%
group_by(business_model) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
# VIsualisierung
ggplot(shipments_without_cancellation,
aes(factor(business_model),
fill = factor(business_model))) +
geom_bar()
# durchschnittliche Marge, aggregiert nach custom rate shipment (falsch, wahr)
shipments_without_cancellation %>%
group_by(custom_rate_shipment) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
tapply(shipments_without_cancellation$margin ,shipments_without_cancellation$custom_rate_shipment ,sum)
# Visualisierung
ggplot(shipments_without_cancellation,
aes(factor(custom_rate_shipment),
fill = factor(custom_rate_shipment))) +
geom_bar()
# durchschnittliche Marge, aggregiert nach fulfillment strategy (bulk, fullTRuck, palett)
shipments_without_cancellation %>%
group_by(fulfilment_strategy) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
tapply(shipments_without_cancellation$margin ,shipments_without_cancellation$fulfilment_strategy ,sum)
# Visualisierung
ggplot(shipments_without_cancellation,
aes(factor(fulfilment_strategy),
fill = factor(fulfilment_strategy))) +
geom_bar()
xtabs(~ custom_rate_shipment + fulfilment_strategy, data = shipments_without_cancellation)
# durchschnittliche Marge, aggregiert nach lane domain (export, import, national, international)
shipments_without_cancellation %>%
group_by(lane_domain) %>%
summarize(mean_margin = mean(margin, na.rm = TRUE))
tapply(shipments_without_cancellation$margin ,shipments_without_cancellation$lane_domain ,sum)
ggplot(shipments_without_cancellation,
aes(factor(lane_domain),
fill = factor(lane_domain))) +
geom_bar()
cor(shipments_without_cancellation$stops_count, shipments_without_cancellation$margin)
cor(shipments_without_cancellation$stops_count, shipments_without_cancellation$margin, method = "kendall")
cor(shipments_without_cancellation$stops_count, shipments_without_cancellation$margin, method = "spearman")
